假设你现在正构建一个社交网络，其中，每个用户指定了一系列特征。
你需要在未配对的用户集合中把用户属性相同的进行配对。

给定一个用户的序列，其中每个用户有一个32位的整型key，以及用字符串标识的一系列特征。
当你读入一个用户时，你应该与先前读入的未匹配的特征符合的用户进行匹配，如果这个用户存在的话。
如果用户未匹配到，应该把他加入到未匹配的集合中

*提示：将特征集合映射到字符串*

答：首先，我们来看下这个问题的核心算法，接着我们将考虑详细的实现，特别是关于扩展的内容。
一个暴力的方法就是比较当前用户与未匹配用户的特征，这样的话时间复杂度是O(n2)，n是用户数量
为了提高时间复杂度，我们需要根当前用户特征一样的目前用户的方法。
此时使用一个以用户特征值作为key，以用户作为value的哈希表是个不错的选择。
摆在我们面前的一个问题是怎样设计一个哈希方法，适用于所有特征值。

如果所有特征的数量是很小时，我们可以用一个位队列来表示特征集合，其中每个下标代表一个具体的特征。
再详细一点就是我们在这个下标对应的值若为1则表示这个特征出现了。
我们进而可以用任何一个可以用于位队列的哈希方程。处理n个用户就是逐次进行哈希查找，因此时间复杂度是O(mn)，m是特征的个数。
空间复杂度也是O(mn)，n个实例，其中每个大小为m。

如果特征集合非常大，但是大部分用户只有一小部分特征，那子集位向量从时间和空间上来看效率很低。
一个更好的用来描述稀疏子集的方法是直接记录元素。为了保证相同的子集有相同的哈希码，我们需要用一种特殊的方法来表示子集。
一个方法时把所有元素排序，可以把排序后的特征作为一个单一字符串，也就是独立元素的拼接。我们使用一个对所有字符串统一的哈希方法。
例如，如果备选的特征是USA, Senior, Incom, Prime, Customer，用户的特征是USA, Income，
那我们可以把他的特征集合描述为字符串"Income, USA"。
时间复杂度为O(M)，其中M是所有用户特征集合的总和。

现在我们来考虑下具体的实现事宜。假设网络很小，单个机器就能满足存储。
对于这样一个系统来说，你可以使用数据库，包括用户表，特征表，以及一个join表连接它们。
对于每一个特征来说，你将能找到所有的匹配结果（或不匹配），以及根据条件你可以决定是否加入或新建一个组。
如果你不喜欢用数据库而是想重复造轮子，可以使用相同的方法获取特征值对应的匹配用户的ID。
要实现它需要使用反向索引，以及一个哈希字符串用来在存储中快速的查找。
假设数组返回的结果是有序的，则有一个简单的方法来合并多个特征值的数组，做出是否加入新组的决定。
现在假设网络很大，以至于单个机器不能满足需求。因为有很多的用户，所以有必要讨论下在多个多个机器上得问题——每个机器将存储特征的子集
返回用户的ID，我们需要做两个合并操作。
- 确认搜索结果——当单个特征的查找在多个机器上实现时，我们需要合并返回的有序IDs为一个大的有序列表
— 不同特征的所搜结果——我们需要合并在所有列表中出现的那些特征值的结果
由于非常有可能我们不需要做一个实时的匹配，我们可以使用生产者——消费者模式：从一个队列中选取，然后做搜索，因此可以限制同时并发的请求数。


